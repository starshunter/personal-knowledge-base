- # Midnight
- DONE commit journal
- write the draft of self introduction #[[Job Interview]]
  id:: 6203e0f4-4956-4f0c-a9b7-7fc28425f232
	- 你好，我是鄭宇翔，去年畢業於台大資管系。在學期間我著重在學習資訊科學的基礎理論以及軟體開發的技術，過程中發現進行軟體開發能夠帶給我極大的成就感，所以決定畢業後要踏入這個行業。
	- 在學時，我透過多個課堂專案取得與他人合作進行軟體開發的機會。透過這些機會，我學到如何與共同開發的夥伴們溝通，用小型且具體的開發項目掌握彼此的進度，並以此為依據溝通並分配未來的工作，這樣同時間也培養了我對開發時程的敏銳度和訂定開發計畫的技巧，相信這些寶貴的經驗能夠在職場上讓我更順利的融入團隊。
	- 另外，我也是一個學習能力出色，並且渴望學習新技術的人。例如在專題課程期間，在其他組員都沒有相關經驗的情況下，我透過各種網路資源學習如何用React Native開發應用程式，並教受組員相關技術使專題能夠步上正軌。另外，大四時我也利用即將畢業的閒暇時間，在網路上學習如何用Golang開發，並結合我在課堂上學到的後端技術，寫出可以讓我的個人網頁可以正常運作的後端程式。
	- 上述的這兩點特質，也是為什麼我這次會來應徵貴公司所開的職缺。這個職缺所運用的技術是我有經驗的，另外貴公司在描述希望尋找的人選時所提到的人格特質，我也相當符合這樣的描述。而且貴公司在這個領域是長期經營，市場上有一定的名聲和影響力，而進入貴公司工作，也代表有機會開發到在市場上被廣泛使用的系統，肯定能夠大幅提升我的開發技術。
	- 總結來說，軟體開發是我的專長也是我的興趣，如果有幸加入，我相信我的人格特質以及專長一定能夠幫助團隊的成果更上一層樓，謝謝。
- [[勿說是推理/EP4]]
	- inference in this episode is a bit exaggerated
	- the setting of a bomber that lost memory is interesting
	- when the bomber lost his memory, he seems to be more open about his past
	- something happened between man lead and his mom, maybe that's what shaped his personality
- 02:53 #[[Bed Time]]
- # Morning
- 09:40 #[[Wake Time]]
- [[LeetCode Daily Challenge/2022-02]] #[[Hash Table]] #String #[[Bit Manipulation]] #Sorting
  id:: 621cbb95-d4f5-49da-a6d0-4c902da3bac6
	- problem:: Find the Difference
	  link:: https://leetcode.com/problems/find-the-difference/
	  difficulty:: Easy
	  duration:: 5 mins
	- third time solving this problem
	- easy using addition space
	- use XOR to do it in place
- [[The Go Workshop/Files and Systems]] #Golang/OS #Golang/IO
	- command line flags and their arguments #Golang/Syntax
		- use `flag` package to define our own flags
			- every function inside `flag` has function signature of
			  `func <func name>(name string, value <type>, usage string) *<type>`
			- these type of functions create a flag with input name, a default value and a detail string about this flag
		- use `flag.Parse()` to get the values for flags from command line
		- use `flag.PrintDefaults()` to print default messages for all flags
	- system interrupt signal
		- when a program receive an exit signal, the program will terminate immediately, deferred functions will not be executed
			- which may damage program's integrity
		- we can register these signals so that our program can execute correctly
		- use `signal.Notify()` to send received signal to a channel
			- `signal.Notify(<channel>, <signal 1>, <signal 2>, ...)`
	- file access permission
		- use symbol to represent permission
		- readable
			- r
			- 4
		- writable
			- w
			- 2
		- executable
			- e
			- 1
		- no permission
			- -
			- 0
		- these permissions can be combined into an octal number
	- create and write into a file
		- create a file #Golang/IO
			- `os.Create(<file name>)`
			- `os.Create()` will return a file pointer to the created file
			- if that file already exist, then the content will be wiped out
		- write strings into a file
			- use `Write()` or `WriteString()` method of a file pointer to write into a file #Golang/IO
				- `<file>.Write(<byte slice>)`
				- `<file>.WriteString(<string>)`
			- or use `os.WriteFile()`, this function will also create the specified file if the file didn't exist, and wipe out the content if it exist #Golang/IO
				- `func WriteFIle(filename string, data []byte, perm os.FIleModes) error`
		- check file existence
			- use `os.State()` to check a file's status #Golang/IO
				- `<info>, <error> := os.State(<file name>)`
		- read file's content
			- use `os.ReadFile()` #Golang/IO
				- `func ReadFile(filename string) ([]byte, error)`
			- use `io.ReadAll()` together with `os.Open()`#Golang/IO
				- first use `os.Open()` to open a file, than pass that pointer to `io.ReadAll()`
				- `io.ReadAll(<io.Reader>)`
		- read a line of string in a file #Golang/IO
			- build a `bufio.Reader` using `bufio.NewReaderSize()` from a `os.File` objecgt
			- than use method `ReadString()` to read string until next delimiter
			- `<reader> := bufio.NewReaderSize(<io.Reader>, <buffer size>)`
		- delete file
			- use `os.Remove()` to remove file
	- open file with conditions
		- use `os.OpenFile()`
		- its parameters allow us to decide what action can we take
	- process CSV file #Golang/IO
		- use `csv.NewReader()` to create a csv reader from a file pointer, that use that reader's method `Read()` to read each line into a string slice
- # Afternoon
- # Night
- ![ch01.pdf](../assets/ch01_1644226797701_0.pdf)
	- type:: pdf
	  tags:: [[Operating System/Basic]], [[Learning/Work]], [[Job Interview]]
	  title:: Chapter 1: Introduction
	- what is operating system
		- a program that allows users to interact with computer hardware
		- a resource allocator for user programs
		- a control program to prevent programs from improper use of computer
		- the program running all the time on the computer
	- computer system
		- organization
			- ((6200ef05-b0be-4577-a9c8-6628a36b7c5c))
			- CPUs and device controllers connect to a common bus that has access to the shared memory
			- each device controller has a local buffer and a set of register
			- CPUs move data between these buffers and main memory
		- operation
			- after powering up, a bootstrap program inside ROM will load OS into main memory, then let the OS handle the rest
	- interrupt
		- without interrupt mechanism, CPU will have to busy wait an operation to finish, and then proceed to its next step
		- when CPU detects an interrupt
			- it will save current process's address and state
			- OS use interrupt ID to call interrupt service routine in the interrupt vector
			- CPU runs interrupt service routine
			- resume to previous process
		- interrupts will be disabled while CPU is processing another interrupt
			- CPU will not be interrupted, but the interrupt will be remembered by interrupt handler
			- via [this](https://stackoverflow.com/questions/32812704/interrupts-disabled-during-interrupt-handling) question
		- ((620111c7-625f-4a5e-a3bc-8ee43210d37d))
	- storage
		- CPU can only access
			- registers
				- built inside CPU
				- CPU can fetch instructions from them
			- main memory
				- program must be in here to be executed
		- CPU execution cycle
			- fetch instruction from register
			- CPU decodes the instruction
			- fetch operands from main memory if necessary
			- execute instruction
			- store the result back to memory
		- secondary storage
			- impossible for all the programs and data to reside in main memory
				- small
				- volatile
			- organized in hierarchy according to speed and cost
	- I/O
		- a computer consists of CPUs and multiple device controllers connected through a common bus
		- device controller has some local buffers and a set of registers
		- OS has a device driver for each device controller
			- it offers a uniform interface for the OS
		- ((62012106-aa20-41ff-8d53-8594315277bb))
		- procedure of I/O operation
			- device driver loads the registers within the device controller
			- device controller than decide what action to take base on the registers
			- controller transfer data from device to its buffer
			- controller informs driver through interrupt once the transfer is completed
			- ((62012215-34fd-4134-919d-df3572ec78c4))
	- system architecture
		- single processor
			- has one main CPU for general purpose
			- other processors are for special purpose
		- multiprocessor
			- has two or more processors that share same computation resource
			- advantage
				- increased throughput
				- economy of scale
					- shared resource
				- increased reliability
					- failure of one processor doesn't stop the whole system
			- types
				- asymmetric
					- a master processor coordinates others
				- symmetric
					- all processors perform all tasks within the OS
	- OS structure
		- multiprogramming
			- jobs are kept in memory
			- OS organizes jobs so CPU always has one to execute
		- time sharing (multitasking)
			- an extension of multiprogramming
			- CPU switches jobs frequently
			- user then thinks the entire computer is dedicated to his use
		- main memory cannot store all the jobs, so they are kept on the disk in the job pool
			- job scheduling service selects jobs from the job pool and loads them into memory
			- if a process doesn't fit in memory, then swapping is needed
	- dual-mode operation
		- to ensure proper execution of OS, we must distinguish between OS code and user code
		- control is switched to OS via interrupt, trap or system call
		- user mode
			- request OS services via system call
		- kernel mode
			- can manage computation resources
		- system call procedure
			- system call is treated by hardware as trap
			- mode bit set to 0
			- OS examine the trap and use interrupt vector to determine which interrupt service routine to execute
			- return control to the instruction following the system call
	- process management
		- process is an executing program
		- including
			- creation and deletion of user and system processes
			- suspending and resuming processes
			- process synchronization and communication
			- deadlock handling
	- memory management
		- instructions must be in memory in order to execute
		- computer needs to keep several programs in memory to improve performance
		- including
			- track memory usage
			- decide which process and data should move into or out of memory
			- allocating and deallocating memory
	- caching
		- we first check cache for information needed
		- we may copy data into cache
		- a data may exist in different place because of storage hierarchy and multiprocessor environment
	- protection and security
		- protection
			- any mechanism for controlling access of processes or users to resources defined by OS
				- user identifier
				- group identifier
		- security
			- defense of the system against internal and external attacks
- ![ch02.pdf](../assets/ch02_1644248535585_0.pdf)
	- type:: pdf
	  tags:: [[Operating System/Basic]], [[Learning/Work]], [[Job Interview]]
	  title:: Chapter 2: System Structures
	- OS services
		- UI
			- CLI
			- GUI
			- batch
		- program execution
			- load the program into memory and execute
		- I/O
			- user control I/O devices through OS
		- file system manipulation
			- permission management of file access
		- communication
			- messages exchange between processes
		- error detection
		- resource allocation
		- accounting
			- keep track of resource usage for each user
		- protection and security
			- ensure all access to system resources is controlled
	- UI
		- CLI
			- implement in kernel or by system program
			- an OS can have multiple command interpreters, or shells
			- two ways to implement
				- command interpreter contains the code to execute the command
				- load the command file into memory for execution
					- reduce interpreter's size
					- make adding new command easy
		- GUI
	- system calls
		- programming interface to services provided by OS
		- user program use system services through API consists of system call
			- API provides a system call interface
			- system call interface decides which system call to send
			- increase portability
			- reduce development complexity
		- ways to pass parameters with system call to OS
			- pass in registers
			- store in block, and pass the block address
			- push them onto a stack
		- types
			- process control
				- end and abort
				- load and execute
				- wait time or event
				- variations
					- single-tasking system
						- interpreter reloads itself after execution
					- multitasking system
						- shell can run processes in the background
			- file management
				- create and delete
				- open and close
				- read, write and reposition
			- device mangement
				- resources controlled by OS can be thought of as devices
				- request, execute and release devices
			- information maintenance
				- transfer system related information between user programs and OS
			- communication
				- message passing
					- create connection between two processes
					- good for exchanging smaller data
					- easy to implement
				- shared memory
					- create shared memory owned by other process
					- read and write at memory speed
					- protection and synchronization is vital
	- system programs
		- OS can be viewed as a collection of system programs
		- interfaces to system calls
		- types
			- file manipulation
			- file modification
			- status information
			- programming language support
			- program loading and executing
			- communications
	- OS design
		- first define requirements and specifications
			- requirements can be divided into user goals and system goals
		- to fulfill requirements, we need to separate policy and mechanism
			- when policy change, mechanism can stay the same
	- OS implementation
		- written in assembly or higher level languages
		- pay more attentions to memory manager and CPU scheduler
	- OS structure
		- simple structure
			- small, simple but limited
			- more functionality increases the complexity
			- ((62015a01-a7ff-4ec3-9416-dea48827d37f))
			- hard to maintain
		- layered approach
			- OS is divided into layers, each built on top of another
			- ((62015a4d-0257-4589-955d-496332eabb02))
			- easy to debug
			- the nature of OS functionality is hard to divide into layer
				- ((62015aa6-1790-4e26-b81c-2e72ae37043c))
			- inefficient
		- microkernels
			- remove services from kernel and implement as system programs
			- services communicate with OS through message exchange
			- easy to include new services, more portable and reliable
			- communication may create unnecessary overhead since services are in user space
		- modules
			- consists of core kernel and services as kernel modules
				- module communicate through interface
			- module can load into memory upon demand appears
	- OS generation
		- SYSGEM is needed
			- it gets the information of hardware
				- CPU
				- memory
				- devices
				- OS options
		- the OS is generated base on the information collected
	- system boot
		- bootstrap program is needed
			- store in ROM and EPROM
			- locate and load the kernel into memory
			- execute kernel
		- bootstrap program may load a more complex bootstrap program from disk
			- located at boot block