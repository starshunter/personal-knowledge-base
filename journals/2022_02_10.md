- # Midnight
- DONE commit journal
- [[Doctor White/EP4]]
	- this episode is about a music teacher only had few months left, and how he chose to accept his death
	- main story barely move
- 04:01 #[[Bed Time]]
- # Morning
- 10:19 #[[Wake Time]]
- [[LeetCode Daily Challenge/2022-02]] #Array #[[Hash Table]] #[[Prefix Sum]]
	- problem:: Subarray Sum Equals K
	  link:: https://leetcode.com/problems/subarray-sum-equals-k/
	  difficulty:: Medium
	  duration:: 30 mins
	- third time solving this problem
	- try to solve it with two pointers initially, then realize array element can be negative
	- use prefix sum and hash table
	- need to be careful if the subarray start from index 0
- ![ch07.pdf](../assets/ch07_1644462539523_0.pdf)
	- type:: pdf
	  tags:: [[Operating System/Basic]], [[Learning/Work]], [[Job Interview]]
	  title:: Chapter 7: Deadlocks
	- system model
		- computer system consists of different resources, and each resources may have multiple identical instances
		- processes may compete for same resource
		- OS is responsible for managing each resource's status
		- a set of processes is said to be in deadlock when every process is waiting for an event that can be caused only by another process in the set
		- hard to detect because it only occurs in certain conditions
		-
	- deadlock characterization
		- mutual exclusion
			- only one process at a time can use a resource
		- circular wait
			- $P_0$ wait for $P_1$, $P_1$ wait for $P_2$, and $P_n$ wait for $P_0$
		- hold and wait
			- a process is holding at least one resource, and is waiting for resources hold by others
		- no preemption
			- a resource can only be released voluntarily by the process that allocate it
	- methods for handling deadlocks
		- ways to handle deadlock
			- design a protocol to prevent or avoid it
				- deadlock prevention
					- method that make sure one of the deadlock conditions doesn't hold
				- deadlock aviodance
					- avoid deadlock by monitoring resources allocation information
			- detect and recover from it
			- ignore the problem
	- deadlock prevention
		- prevent deadlock by ensuring at least one of four necessary conditions can't hold
		- mutual exclusion
			- usually cannot deny it
		- hold and wait
			- ask the process to allocate all the resources it needs before execution
			- allow the process to allocate new resources only when it hold no resource
			- disadvantages
				- low resource utilization
				- starvation
					- process may wait indefinitely
		- no preemption
			- applied to resources whose state can be easily saved and restored
			- if a process is requesting a resource that is allocated to others, then all its resources are preempted
				- process may restart only when it can allocate all the resource
			- if a process is requesting a resource that is allocated to a waiting process, then it can preempt that resource from the process
				- but if that process is running, it has to wait
		- circular wait
			- add ordering to al resource types
			- require processes to allocate resources in ascending order
	- deadlock avoidance
		- construct an algorithm that ensure system never enter deadlock state base on the information provided by OS
		- a state is safe if OS can allocate resources in some order that won't result in a deadlock
		- an unsafe state may lead to a deadlock
		- the algorithm ensures that system will always remain in a safe state
			- every time a process requests a resource, the OS will only grant it if the system remains in safe state after the allocation
	- Banker's algorithm
		- a process must declare the maximum number of instances of each resource type it may need while entering the system
		- the system must determine if the allocation will leave the system in safe state
		- including safety algorithm and resource-request algorithm
	- deadlock detection
	- recovery from deadlock
		- process termination
			- abort all or abort one at a time
		- resource preempt
			- preempt some resources from processes until deadlock is broken
- [[勿說是推理/EP5]]
	- main lead went into hospital and met a retired police
	- that police was pondering whether to reveal his old partner's crime
	- turns out that police already dead, it was just a dream or something
	- and then someone use the book which that police left to meat with him
- # Afternoon
- # Night
- ![ch08.pdf](../assets/ch08_1644488187147_0.pdf)
	- type:: pdf
	  tags:: [[Operating System/Basic]], [[Learning/Work]], [[Job Interview]]
	  title:: Chapter 8: Memory Management Strategies
	- OS must ensure itself cannot be accessed by user processes, and user processes should not be accessed by others
	- use base register and limit register to define a rage of legal addresses for each process
		- any attempt to access memory outside of this rage results in fatal error
	- address binding
		- addresses in the programs are often symbolic
		- compiler will turn these symbolic addresses to relocatable addresses
		- and to bind these relocatable addresses to physical addresses, there are different timing can be done
			- compile time
				- if starting location change, then recompile is needed
			- load time
				- if starting location change, then reload is needed
			- execution time
				- mostly use when the process can be moved during its execution
			- ((62051557-df99-4f99-a578-2c1d76139b5e))
	- logical and physical address
		- logical
			- address generated by the program
		- physical
			- address seen by the memory unit
		- memory management unit
			- a hardware device that maps from logical to physical addresses at runtime
	- dynamic loading
		- a program is not loaded until it is called
		- it's kept on disk in relocatable format
		- the main program that calls this program need to update it address space
		- result in better memory utilization
	- dynamic linking
		- static linking
			- compiled object modules are combined by the loader or linker into the binary program image
		- with dynamic linking, linking is postponed until execution time
		- without dynamic linking, each program may need to include a copy of certain library
		- a stub in the image will check if the required library is already in the memory
	- swapping
		- if there is not enough memory space, a process can be swapped out to backing store, then swapped in later for continued execution
		- if address binding is done at compile or load time, then the process will be swapped back into the same memory space
		- CPU calls [dispatcher](((6203e0f4-471b-48f3-8ea8-9a1038c29bd6))) to switch processes bases on CPU scheduler's decision
			- dispatcher will check the process resides in the memory or not
			- dispatcher will swap out processes then swap in target process
		- standard swapping is rarely used because it requires too much swapping time
	- contiguous memory allocation
		- the memory is generally divided into space for OS and for user processes
		- in contiguous memory allocation, each process is contained in a contiguous space
		- the simplest way to partition memory is to do fixed sized partitions
		- dynamic partitions allow OS to search for holes for a process
		- ways to choose holes
			- first fit
				- allocate the first hole that is big enough
			- best fit
				- allocate the smallest hole that is big enough
			- worst fit
				- allocate the largest hole
	- fragmentation
		- external fragmentation
			- total memory space is enough for a program, but those spaces are not contiguous
		- compaction
			- a solution to external fragmentation
			- merge all spaces into one large block
			- possible only if binding is dynamic and is done at execution time
		- internal fragmentation
			- happens in fixed sized partition
			- memory allocated to a process is slightly larger
	- paging
		- a memory management scheme that allows the physical address space of a process to be noncontiguous
		- memory is broken into fixed sized frames
		- logical memory is broken into fixed sized pages
			- logical memory is divided into page number and page offset
			- page number is used to query base address using page table
			- page offset is to define physical address space with base address
		- ((62052f7f-eaab-4081-beae-729db68e0880))
		- external fragmentation won't occur, but internal fragmentation will
		- OS maintains a frame table for each physical frame's status
		- implementation
			- OS allocates a page table for each process
			- page table is implemented as a set of registers
			- or page table is kept in memory, and a page table base register is implemented
				- use translation look-aside buffer to avoid two memory accesses
				- TLB may contain entries for several processes
					- use address-space identifier to distinguish each process
		- protection
			- use valid-invalid bit to indicate whether a page is in the process's logical space
			- ((6205382b-7b98-47e7-b434-3c3e80899fab))
			- use page-table length register to indicate the size of the page table
		- shared page
			- same program can be invoked into multiple processes, and shared page can reduce memory usage
			- each process's page table maps onto the same physical address
	- hierarchical paging
		- a single page table is too large to allocate it contiguously
		- use two level paging reduce page table size
		- but too many levels result in multiple memory access
		- ((62053eae-4b69-40ba-ab22-dec4f37f138e))
	- hashed page tables
		- ((6205402f-773f-4760-896f-1b3c144f49aa))
	- inverted page tables
		- one table for each process may consume  large amount of memory
		- we can use only one page table, each entry for each frame
		- searching is time consuming
	- segmentation
		- a logical address space is a collection of segments
		- the logical address specify both the segment name and the offset within the segment
		- a segmentation table is needed to map logical addresses to physical addresses
		- ((6205477c-8fb7-4a50-a4ec-5ace686e8506))