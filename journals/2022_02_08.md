- # Midnight
- DONE commit journal
- [[Fight Song/EP4]]
	- the deadline for man lead just shorten to one week
	- female felt that she could do nothing to help him
	- their relationship seemed reaching to the end
	- then men lead watched her participated in a friendly karate competition and got inspired
	- he finally wrote his first song in years, and invited female lead to be the first listener
	- but unfortunately, his song still didn't got pick for use
- 03:45 #[[Bed Time]]
- # Morning
- 08:58 #[[Wake Time]]
- [[LeetCode Daily Challenge/2022-02]] #Math #Simulation #[[Number Theory]] #Proof
	- problem:: Add Digits
	  link:: https://leetcode.com/problems/add-digits/
	  difficulty:: Easy
	  duration:: 15 mins
	- third time solving this problem
	- can easily solve this problem with loop
	- write sequence on paper, and observe there is a pattern
	- there is an edge case between 0 and any other number that modulo 9 equal 0
	- how to prove the pattern valid is important
		- a number can represent as $n = d_0 + 10^1 * d_1 + 10^2 * d_2 + ... + 10^k * d_k$
		- $n = d_0 + d_1 * (9 * 1 + 1) + d_2 * (9 * 11 + 1) + ... + d_k * (9 * 11...1 + 1)$
		- $n = d_0 + d_1 + ... + d_k + 9 * (d_1 * 1 + d_2 * 11 + ... + d_k * 11...1)$
		- $n\space mod\space 9 = (d_0 + d_1 + ... d_k)\space mod\space 9$
		- multiples of 9 need to be discussed as special case
- [[The Go Workshop/SQL and Databases]] #[[Golang/DB]] #[[Golang/SQL]]
	- use `database/sql` package to connect to database
		- `database/sql` provides an interface to interact with different database, and we need to download specific database driver to fulfill this purpose
		- `sql.Open()` will return a `sql.DB` object
		- use `db.Ping()` to check if the connection is alive
	- create, clear and remove table
		- use `db.Exec()` to execute command
	- insert data
		- use prepared statement to avoid SQL injection
			- the command will be compiled first, then insert parameters into the right place
		- use `db.Prepare()` for prepared statement
		- then use statement's method `Exec()` by providing parameters
	- query data
		- use `db.Query()` to go execute query command, which will return a `sql.Rows` struct
		- use `Rows.Scan()` to read row data into struct
		- use `db.Prepare()` for query with parameter
	- update data
		- we can get effected row from execution command
- # Afternoon
- ![ch03.pdf](../assets/ch03_1644311198949_0.pdf)
	- type:: pdf
	  tags:: [[Operating System/Basic]], [[Learning/Work]], [[Job Interview]]
	  title:: Chapter 3: Processes - Concept
	- process
		- a program in execution
		- structure in memory
			- ((6202335f-7225-4698-86c6-e3131db1167c))
			- text
				- program code
			- stack
				- local variable or function parameter
			- data
				- global variable
			- heap
				- space for dynamic memory allocation
			- program counter
				- a pointer point to the instruction being executed
			- register status
		- state
			- new
			- running
			- waiting
				- the process is waiting for some event to occur
			- ready
			- terminated
		- process control block
			- how a process represented in OS
			- information
				- state
				- program counter
				- CPU registers
				- CPU scheduling information
				- memory management information
				- accounting
				- I/O status
	- process scheduling
		- we need process scheduler to select process for CPU execution, and arrange other processes when to be executed
		- OS contains a lot of queues with contain PCBs
		- job queue
			- processes in the queue reside on disk
			- job scheduler select process into memory for execution
			- may be absent on some OS
		- ready queue
			- reside in main memory
			- processes in this queue are ready to execute
		- device queue
			- processes that are waiting for a certain device
		- ((62023dde-169b-4240-856b-7300732e280f))
		- job scheduler
			- long term scheduler
			- select which process should be brought into ready queue
			- control the degree of multiprogramming
				- process may be classified as I/O-bound or CPU-bound
				- a good long term scheduler should select processes that will make system balanced
		- CPU scheduler
			- short term scheduler
			- select which process should be executed by CPU
		- medium term scheduler
			- exist in some OS
			- it removes or reintroduces process from/into memory
			- improve the balance of processes
			- ((62023f84-a10f-4f80-b6c5-6ff753eec574))
	- context switch
		- CPU saves current process's context, and load another process's saved context
		- context is represented in PCB
		- ((62025ee8-0203-41e7-8b73-19cda728dece))
		- context switch time is overhead
	- process creation
		- a process can create multiple processes through system call
		- process is identified by a unique process identifier
		- parent process may share all, or a subset of resource with child process, or even share no resource
		- parent process may wait or execute concurrently with child process
		- child process may duplicate parent's address space, or has a new program load into it
		- use `fork()` to create child process
			- `fork()` will return a value, 0 means it's child process, greater than 0 means parent process
			- use `exec()` to load new program to process's memory space
			- parent process can use `wait()` to wait it's child process to complete execution
			- `exit()` can terminate a process and return a status value to its parent
	- interprocess communication
		- it's a mechanism that allows cooperating processes to exchange data and information
		- shared memory
			- processes share a region of memory
			- communicate through reading and writing
			- done at memory speed
			- ensuring no two processes writing to same location is important
			- a process can create a shared memory, and other processes need to attach it to their address space
			- two types of buffer (shared memory)
				- unbounded
				- bounded
		- message passing
			- messages exchanged between the processes
			- the communication is synchronized
			- useful for smaller amounts of data
				- no conflict need to be avoided
			- slow because of system call
			- direct communication
				- symmetry
					- need to name the recipient or sender
				- asymmetry
					- only the sender need to name the recipient
				- hard to maintain when process identifier change
			- indirect communication
				- messages are sent to and received from mailboxes
				- mailbox can be owned by a process or OS
				- a process can interact with multiple mailbox
			- function design
				- blocking send
				- nonblocking send
				- blocking receive
				- nonblocking receive
			- buffering
				- the buffer can be zero capacity, bounded capacity or unbounded capacity
	- communication in client-server systems
		- sockets
			- an endpoint for communication
			- identified by an IP address and a port number
			- processes communicate through a pair of sockets
		- pipes
			- ordinary pipes
				- unidirectional
				- producer writes, consumer read
				- cannot be accessed from outside the process that created it
					- child process can
			- named pipes
				- can be used in non-parent-child relation
		- remote procedure calls
			- message-based communication
				- messages are well structured
			- allows a client to invoke a procedure on a remote host
			- stubs at both client and server side, act as proxy
			- parameter marshalling
				- data representation is different on different machine
				- parameters are marshaled into standard format, and let receiving side to unmarshaled to its data representation
			- ((62027fd3-23c1-4d5f-8462-3752148d0f30))
- # Night
- ![ch04.pdf](../assets/ch04_1644331500085_0.pdf)
	- type:: pdf
	  tags:: [[Operating System/Basic]], [[Learning/Work]], [[Job Interview]]
	  title:: Chapter 4: Multithreaded Programming
	- multithreaded process can perform more than one task at a time
	- thread
		- a basic unit of CPU utilization
		- consist of
			- thread ID
			- program counter
			- registers set
			- stack
		- threads in same process share
			- text (code)
			- data
			- OS resources
		- benefits
			- responsiveness
				- an application can keep running even a thread is blocked
			- resource sharing
			- economy
				- resource allocation and context switch for process are slow
			- utilization of multiprocessor architecture
	- multithreading models
		- user thread and kernel threads
			- user threads are supported by user program and managed without kernel support
			- kernel threads are supported and managed by OS
		- many-to-one model
			- ((620295a0-876c-4a5f-8c14-953ecaca77b9))
			- thread management is done by thread library in user space
			- cannot utilize multiprocessor structure
			- the process will block if one thread makes a blocking system call
		- one-to-one model
			- ((6202968a-8b25-49ab-bc5a-00b4ebebfc3d))
			- to run a user thread, a corresponding kernel thread need to be created
				- result in overhead
		- many-to-many model
			- ((620296dd-4615-46c6-bdea-0a5b5c85ec70))
			- overcome the downside of last two models
		- a good [sum up](https://www.kshuang.xyz/doku.php/operating_system:course_concept:thread)
	- thread libraries
		- provide programmer an API for creating and managing threads
			- ways of implementation
				- library only in user space
					- no system call
				- kernel level library
					- a function call results in a system call
	- scheduler activations
		- lightweight process
			- virtual processor
			- an intermediate data structure between user thread and kernel thread
			- kernel provides a set of LWP to an application
			- a LWP can be used to schedule a user thread from user thread library's view
		- procedure
			- a user thread may block LWP and kernel thread if it makes a blocking system call
			- kernel informs application through upcall
			- kernel allocate another LWP for application, and application runs upcall handler to handle upcall on that LWP
			- upcall handler saves the state of the blocking thread and release the blocking LWP
			- upcall handler assign an user thread to new LWP
			- kernel inform application through upcall when the blocked thread can run again