- # Midnight
- DONE commit journal
- 00:36 #[[Bed Time]]
- # Morning
- 06:55 #[[Wake Time]]
- # Afternoon
- [[LeetCode Daily Challenge/2022-02]] #Array #[[Hash Table]] #[[Prefix Sum]]
  id:: 621cbb95-1f81-4f3e-96cc-d4536cb06e3a
	- problem:: Contiguous Array
	  link:: https://leetcode.com/problems/contiguous-array/
	  difficulty:: Medium
	  duration:: 10 mins
	- second time solving this problem
	- try to figure out how to not use unordered_map according to my note from last time
	- use prefix sum
	- need to be careful of the case where prefix sum is 0, it indicates the range start from index 0
- # Night
- [[The Go Workshop/Packages]] #[[Golang/Packages]]
	- benefits of package
		- ease of maintenance
		- reusability
		- modularity
	- a package can contains multiple files
		- but every file under certain package should have the same package name
	- only exported variable, type or function can be accessed by programs outside of current package
		- set first letter to uppercase for things that you want to export
	- `GOROOT` is the path where your computer install go, it's also the path where standard packages reside
	- since 1.16, you should use go modules to manage your packages
	- to import package, the import path should be `module name/package`
	- use `go get` to download third party package or module
	- downloaded third party packages will be placed in `GOPATH/pkg/mod`
	- package alias
		- `import <alias> <package>` #Golang/Syntax
	- `init()` function
		- packages can be divided to executable and unexecutable
		- only `main` package is executable
		- for all packages, we can use `init()` to set initial state and values for the package
		- procedure
			- initialize outside packages
			- initialize package
			- call outside packages' `init()`
			- call package's `init()`
			- execute `main()`
		- a package allows multiple `init()`, the order of execution is from top to bottom
		-
- ![Chapter_4_2019_notes.pdf](../assets/Chapter_4_2019_notes_1643988523065_0.pdf)
  id:: 61fdd883-98a0-4d34-8ff6-7c68314476ec
	- type:: pdf
	  tags:: [[Computer Network/Basic]], [[Learning/Work]], [[Job Interview]]
	  title:: Chapter 4: Network Layer
	- responsibility
		- transport segment from sending host to receiving host
		- encapsulate and decapsulate segments and datagrams
	- difference between routing and forwarding
		- {{embed ((61fd06fb-35c9-45f8-8396-44af2acfe09c))}}
		- {{embed ((61fd06fb-20b9-460c-8212-b0429b466864))}}
	- Internet doesn't guarantee bandwidth, loss, order or timing
	- virtual circuits
		- need to setup connection before communication
		- each packet has a VC identifier, no destination address
		- routers maintain forwarding table for connections passing by
		- VC can be changed on each link base on forwarding table
		- complexity inside network
	- datagram networks
		- no set up call required
		- routers know nothing about end-to-end connection
		- packet being forwarded base on destination address
		- forwarding table consists of different ranges and corresponding output links
			- use longest prefix matching to represent ranges
		- complexity at edge
	- router
		- run routing algorithms and forward datagrams from input port to output port
		- three types of switching fabrics
			- memory
				- oldest
				- packet copied to memory, thus speed is limited by memory bandwidth
			- bus
				- share bus between input ports and output ports
				- speed limited by bus bandwidth
			- crossbar
		- queuing
			- output port queuing
				- arrival rate exceeds output speed
				- cause packet delay and loss
			- input port queuing
				- switching fabric slower than input ports combined
				- cause packet delay and loss
				- head-of-the-line occurs when datagram at front of the queue blocks datagrams behind from moving forward to no contention output ports
	- Internet protocol
		- datagram format
			- ((61fd5840-bcf9-42d8-b39d-6e730c94b467))
		- fragmentation and reassembly
			- network links have different largest frame limit
			- large datagram need to be divided to smaller datagrams, and reassemble later at destination
				- use fields in header to achieve
		- addressing
			- IP address consists of 32 bit binary
			- one IP address for one interface
			- CIDR
				- a.b.c.d/x, where x is number of bits in subnet portion of address
			- DHCP
				- dynamically get address from server
				- use UDP
				- allows address lease renewal
				- allows reuse of address
				- ((61fd5eb5-f43c-4f92-8a2c-cfc4cbdd92cb))
					- client broadcasts discover message on the subnet
					- server responds with offer message, also reserves an IP address for client
					- client than choose an IP address from the offer it gets, than broadcast request message to tell all the servers which server it chooses
					- the chosen server than respond with ACK message
				- DHCP can also return address of first hop router, IP of DNS server and network mask
		- subntes
			- interfaces with same subnet part of IP address
			- can reach other without router
	- NAT
		- network address translation
		- local network uses just one IP address from outside world's perspective
			- save IP address
			- change IP address inside the subnet without informing outside world
			- change of ISP does not affect local network
		- NAT router must modify outgoing and incoming datagram, and also remember outgoing address and local address mapping
		- mapping of NAT is inconsistent, so may cause some problem
			- want to connect to a server inside LAN using NAT, how?
				- statically configure the mapping
				- use some other protocols that allow server to learn outgoing IP address
				- relaying, both sides connect to another server
	- ICMP
		- Internet control message protocol
		- used by hosts and routers to communicate network information
		- use by traceroute
	- IPv6
		- fixed, 40 byte header
		- no fragmentation by router, only at end-system
		- add
			- priority
			- flow label
			- next header
		- remove
			- checksum
			- options
		- transition
			- unrealistic to upgrade all routers in a short time
			- tunneling
				- IPv6 datagram carried in IPv4 datagram
			-
	- routing
		- global or decentralized
			- global means all routers know the cost info of the network
			- decentralized means router only knows its neighbors' state, and need to constantly exchange its state with others
		- static or dynamic
			- static means routes change slowly
			- dynamic means routers change more quickly in response to link information
		- link state routing algorithm
			- network topology and link costs are known by all nodes
			- use Dijkstra's algorithm
				- starting from initial set containing only the source
				- incrementally add the node into the set that is closest to the source
				- know k different least cost path after k iterations
				- $O(ElogV)$ time complexity using priority queue
				- may cause oscillation
		- distance vector algorithm
			- each router maintains a distance vector of all its neighbors
			- routers exchange distance vector from time to time and update its own distance vector
			- may have count to infinity problem
				- router send incorrect path information
				- solved by [poison reverse](https://en.wikipedia.org/wiki/Split_horizon_route_advertisement)
				- or limit maximum hops allow
			- use Bellman-Ford algorithm
		- hierarchical routing
			- without hierarchy, we will have to store all information in routers
			- arrange routers into different autonomous systems (AS)
				- routers in same AS run same routing protocol
				- different AS communicate through gateway routers with inter-AS protocol
			- hot potato routing
				- if a subnet is reachable from multiple gateway, than router should choose the gateway with smallest least cost path
			- intra-AS routing
				- RIP
					- distance vector algorithm
					- exchange DV every 30s and list up to 25 destination subnets inside DV
					- declare link is dead if no advertisement heard after certain time
					- use poison reverse
				- OSPF
					- link state algorithm
					- hierarchical OSPF
						- two level
						- area border routers summarize distances in own area and advertise to other routers
						- backbone routers runt OSPF limited to backbone
						- boundary routers connect to other AS
			- inter-AS routing
				- BGP
					- eBGP
						- obtain subnet reachability information from neighboring AS
					- iBGP
						- propagate reachability information to all internal routers
					- message exchange over TCP